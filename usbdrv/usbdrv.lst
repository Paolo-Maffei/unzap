   1               		.file	"usbdrv.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.global __do_copy_data
   8               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
  94               	.global	usbInit
  96               	usbInit:
  97               		.stabd	46,0,0
   1:usbdrv/usbdrv.c **** /* Name: usbdrv.c
   2:usbdrv/usbdrv.c ****  * Project: AVR USB driver
   3:usbdrv/usbdrv.c ****  * Author: Christian Starkjohann
   4:usbdrv/usbdrv.c ****  * Creation Date: 2004-12-29
   5:usbdrv/usbdrv.c ****  * Tabsize: 4
   6:usbdrv/usbdrv.c ****  * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
   7:usbdrv/usbdrv.c ****  * License: GNU GPL v2 (see License.txt) or proprietary (CommercialLicense.txt)
   8:usbdrv/usbdrv.c ****  * This Revision: $Id: usbdrv.c 530 2008-02-28 15:34:04Z cs $
   9:usbdrv/usbdrv.c ****  */
  10:usbdrv/usbdrv.c **** 
  11:usbdrv/usbdrv.c **** #include "iarcompat.h"
  12:usbdrv/usbdrv.c **** #ifndef __IAR_SYSTEMS_ICC__
  13:usbdrv/usbdrv.c **** #   include <avr/io.h>
  14:usbdrv/usbdrv.c **** #   include <avr/pgmspace.h>
  15:usbdrv/usbdrv.c **** #endif
  16:usbdrv/usbdrv.c **** #include "usbdrv.h"
  17:usbdrv/usbdrv.c **** #include "oddebug.h"
  18:usbdrv/usbdrv.c **** 
  19:usbdrv/usbdrv.c **** /*
  20:usbdrv/usbdrv.c **** General Description:
  21:usbdrv/usbdrv.c **** This module implements the C-part of the USB driver. See usbdrv.h for a
  22:usbdrv/usbdrv.c **** documentation of the entire driver.
  23:usbdrv/usbdrv.c **** */
  24:usbdrv/usbdrv.c **** 
  25:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
  26:usbdrv/usbdrv.c **** 
  27:usbdrv/usbdrv.c **** /* raw USB registers / interface to assembler code: */
  28:usbdrv/usbdrv.c **** uchar usbRxBuf[2*USB_BUFSIZE];  /* raw RX buffer: PID, 8 bytes data, 2 bytes CRC */
  29:usbdrv/usbdrv.c **** uchar       usbInputBufOffset;  /* offset in usbRxBuf used for low level receiving */
  30:usbdrv/usbdrv.c **** uchar       usbDeviceAddr;      /* assigned during enumeration, defaults to 0 */
  31:usbdrv/usbdrv.c **** uchar       usbNewDeviceAddr;   /* device ID which should be set after status phase */
  32:usbdrv/usbdrv.c **** uchar       usbConfiguration;   /* currently selected configuration. Administered by driver, but no
  33:usbdrv/usbdrv.c **** volatile schar usbRxLen;        /* = 0; number of bytes in usbRxBuf; 0 means free, -1 for flow cont
  34:usbdrv/usbdrv.c **** uchar       usbCurrentTok;      /* last token received or endpoint number for last OUT token if != 
  35:usbdrv/usbdrv.c **** uchar       usbRxToken;         /* token for data we received; or endpont number for last OUT */
  36:usbdrv/usbdrv.c **** uchar       usbMsgLen = 0xff;   /* remaining number of bytes, no msg to send if -1 (see usbMsgPtr) 
  37:usbdrv/usbdrv.c **** volatile uchar usbTxLen = USBPID_NAK;   /* number of bytes to transmit with next IN token or handsh
  38:usbdrv/usbdrv.c **** uchar       usbTxBuf[USB_BUFSIZE];/* data to transmit with next IN, free if usbTxLen contains hands
  39:usbdrv/usbdrv.c **** #if USB_COUNT_SOF
  40:usbdrv/usbdrv.c **** volatile uchar  usbSofCount;    /* incremented by assembler module every SOF */
  41:usbdrv/usbdrv.c **** #endif
  42:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT
  43:usbdrv/usbdrv.c **** volatile uchar usbTxLen1 = USBPID_NAK;  /* TX count for endpoint 1 */
  44:usbdrv/usbdrv.c **** uchar       usbTxBuf1[USB_BUFSIZE];     /* TX data for endpoint 1 */
  45:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
  46:usbdrv/usbdrv.c **** volatile uchar usbTxLen3 = USBPID_NAK;  /* TX count for endpoint 3 */
  47:usbdrv/usbdrv.c **** uchar       usbTxBuf3[USB_BUFSIZE];     /* TX data for endpoint 3 */
  48:usbdrv/usbdrv.c **** #   endif
  49:usbdrv/usbdrv.c **** #endif
  50:usbdrv/usbdrv.c **** 
  51:usbdrv/usbdrv.c **** /* USB status registers / not shared with asm code */
  52:usbdrv/usbdrv.c **** uchar           *usbMsgPtr;     /* data to transmit next -- ROM or RAM address */
  53:usbdrv/usbdrv.c **** static uchar    usbMsgFlags;    /* flag values see below */
  54:usbdrv/usbdrv.c **** 
  55:usbdrv/usbdrv.c **** #define USB_FLG_TX_PACKET       (1<<0)
  56:usbdrv/usbdrv.c **** /* Leave free 6 bits after TX_PACKET. This way we can increment usbMsgFlags to toggle TX_PACKET */
  57:usbdrv/usbdrv.c **** #define USB_FLG_MSGPTR_IS_ROM   (1<<6)
  58:usbdrv/usbdrv.c **** #define USB_FLG_USE_DEFAULT_RW  (1<<7)
  59:usbdrv/usbdrv.c **** 
  60:usbdrv/usbdrv.c **** /*
  61:usbdrv/usbdrv.c **** optimizing hints:
  62:usbdrv/usbdrv.c **** - do not post/pre inc/dec integer values in operations
  63:usbdrv/usbdrv.c **** - assign value of PRG_RDB() to register variables and don't use side effects in arg
  64:usbdrv/usbdrv.c **** - use narrow scope for variables which should be in X/Y/Z register
  65:usbdrv/usbdrv.c **** - assign char sized expressions to variables to force 8 bit arithmetics
  66:usbdrv/usbdrv.c **** */
  67:usbdrv/usbdrv.c **** 
  68:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
  69:usbdrv/usbdrv.c **** 
  70:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS == 0
  71:usbdrv/usbdrv.c **** 
  72:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_0 == 0
  73:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_0
  74:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_0    sizeof(usbDescriptorString0)
  75:usbdrv/usbdrv.c **** PROGMEM char usbDescriptorString0[] = { /* language descriptor */
  76:usbdrv/usbdrv.c ****     4,          /* sizeof(usbDescriptorString0): length of descriptor in bytes */
  77:usbdrv/usbdrv.c ****     3,          /* descriptor type */
  78:usbdrv/usbdrv.c ****     0x09, 0x04, /* language index (0x0409 = US-English) */
  79:usbdrv/usbdrv.c **** };
  80:usbdrv/usbdrv.c **** #endif
  81:usbdrv/usbdrv.c **** 
  82:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_VENDOR == 0 && USB_CFG_VENDOR_NAME_LEN
  83:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_VENDOR
  84:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_VENDOR   sizeof(usbDescriptorStringVendor)
  85:usbdrv/usbdrv.c **** PROGMEM int  usbDescriptorStringVendor[] = {
  86:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_VENDOR_NAME_LEN),
  87:usbdrv/usbdrv.c ****     USB_CFG_VENDOR_NAME
  88:usbdrv/usbdrv.c **** };
  89:usbdrv/usbdrv.c **** #endif
  90:usbdrv/usbdrv.c **** 
  91:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_PRODUCT == 0 && USB_CFG_DEVICE_NAME_LEN
  92:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_PRODUCT
  93:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_PRODUCT   sizeof(usbDescriptorStringDevice)
  94:usbdrv/usbdrv.c **** PROGMEM int  usbDescriptorStringDevice[] = {
  95:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_DEVICE_NAME_LEN),
  96:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_NAME
  97:usbdrv/usbdrv.c **** };
  98:usbdrv/usbdrv.c **** #endif
  99:usbdrv/usbdrv.c **** 
 100:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER == 0 && USB_CFG_SERIAL_NUMBER_LEN
 101:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
 102:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    sizeof(usbDescriptorStringSerialNumber)
 103:usbdrv/usbdrv.c **** PROGMEM int usbDescriptorStringSerialNumber[] = {
 104:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_SERIAL_NUMBER_LEN),
 105:usbdrv/usbdrv.c ****     USB_CFG_SERIAL_NUMBER
 106:usbdrv/usbdrv.c **** };
 107:usbdrv/usbdrv.c **** #endif
 108:usbdrv/usbdrv.c **** 
 109:usbdrv/usbdrv.c **** #endif  /* USB_CFG_DESCR_PROPS_STRINGS == 0 */
 110:usbdrv/usbdrv.c **** 
 111:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_DEVICE == 0
 112:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_DEVICE
 113:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_DEVICE  sizeof(usbDescriptorDevice)
 114:usbdrv/usbdrv.c **** PROGMEM char usbDescriptorDevice[] = {    /* USB device descriptor */
 115:usbdrv/usbdrv.c ****     18,         /* sizeof(usbDescriptorDevice): length of descriptor in bytes */
 116:usbdrv/usbdrv.c ****     USBDESCR_DEVICE,        /* descriptor type */
 117:usbdrv/usbdrv.c ****     0x10, 0x01,             /* USB version supported */
 118:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_CLASS,
 119:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_SUBCLASS,
 120:usbdrv/usbdrv.c ****     0,                      /* protocol */
 121:usbdrv/usbdrv.c ****     8,                      /* max packet size */
 122:usbdrv/usbdrv.c ****     /* the following two casts affect the first byte of the constant only, but
 123:usbdrv/usbdrv.c ****      * that's sufficient to avoid a warning with the default values.
 124:usbdrv/usbdrv.c ****      */
 125:usbdrv/usbdrv.c ****     (char)USB_CFG_VENDOR_ID,/* 2 bytes */
 126:usbdrv/usbdrv.c ****     (char)USB_CFG_DEVICE_ID,/* 2 bytes */
 127:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_VERSION, /* 2 bytes */
 128:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_VENDOR != 0 ? 1 : 0,         /* manufacturer string index */
 129:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_PRODUCT != 0 ? 2 : 0,        /* product string index */
 130:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER != 0 ? 3 : 0,  /* serial number string index */
 131:usbdrv/usbdrv.c ****     1,          /* number of configurations */
 132:usbdrv/usbdrv.c **** };
 133:usbdrv/usbdrv.c **** #endif
 134:usbdrv/usbdrv.c **** 
 135:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_HID_REPORT != 0 && USB_CFG_DESCR_PROPS_HID == 0
 136:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_HID
 137:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_HID     9   /* length of HID descriptor in config descriptor below */
 138:usbdrv/usbdrv.c **** #endif
 139:usbdrv/usbdrv.c **** 
 140:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_CONFIGURATION == 0
 141:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_CONFIGURATION
 142:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_CONFIGURATION   sizeof(usbDescriptorConfiguration)
 143:usbdrv/usbdrv.c **** PROGMEM char usbDescriptorConfiguration[] = {    /* USB configuration descriptor */
 144:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescriptorConfiguration): length of descriptor in bytes */
 145:usbdrv/usbdrv.c ****     USBDESCR_CONFIG,    /* descriptor type */
 146:usbdrv/usbdrv.c ****     18 + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT + (USB_CFG_DESCR_PROPS_HID & 0xff), 0,
 147:usbdrv/usbdrv.c ****                 /* total length of data returned (including inlined descriptors) */
 148:usbdrv/usbdrv.c ****     1,          /* number of interfaces in this configuration */
 149:usbdrv/usbdrv.c ****     1,          /* index of this configuration */
 150:usbdrv/usbdrv.c ****     0,          /* configuration name string index */
 151:usbdrv/usbdrv.c **** #if USB_CFG_IS_SELF_POWERED
 152:usbdrv/usbdrv.c ****     USBATTR_SELFPOWER,      /* attributes */
 153:usbdrv/usbdrv.c **** #else
 154:usbdrv/usbdrv.c ****     (char)USBATTR_BUSPOWER, /* attributes */
 155:usbdrv/usbdrv.c **** #endif
 156:usbdrv/usbdrv.c ****     USB_CFG_MAX_BUS_POWER/2,            /* max USB current in 2mA units */
 157:usbdrv/usbdrv.c **** /* interface descriptor follows inline: */
 158:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescrInterface): length of descriptor in bytes */
 159:usbdrv/usbdrv.c ****     USBDESCR_INTERFACE, /* descriptor type */
 160:usbdrv/usbdrv.c ****     0,          /* index of this interface */
 161:usbdrv/usbdrv.c ****     0,          /* alternate setting for this interface */
 162:usbdrv/usbdrv.c ****     USB_CFG_HAVE_INTRIN_ENDPOINT,   /* endpoints excl 0: number of endpoint descriptors to follow *
 163:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_CLASS,
 164:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_SUBCLASS,
 165:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_PROTOCOL,
 166:usbdrv/usbdrv.c ****     0,          /* string index for interface */
 167:usbdrv/usbdrv.c **** #if (USB_CFG_DESCR_PROPS_HID & 0xff)    /* HID descriptor */
 168:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescrHID): length of descriptor in bytes */
 169:usbdrv/usbdrv.c ****     USBDESCR_HID,   /* descriptor type: HID */
 170:usbdrv/usbdrv.c ****     0x01, 0x01, /* BCD representation of HID version */
 171:usbdrv/usbdrv.c ****     0x00,       /* target country code */
 172:usbdrv/usbdrv.c ****     0x01,       /* number of HID Report (or other HID class) Descriptor infos to follow */
 173:usbdrv/usbdrv.c ****     0x22,       /* descriptor type: report */
 174:usbdrv/usbdrv.c ****     USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH, 0,  /* total length of report descriptor */
 175:usbdrv/usbdrv.c **** #endif
 176:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT    /* endpoint descriptor for endpoint 1 */
 177:usbdrv/usbdrv.c ****     7,          /* sizeof(usbDescrEndpoint) */
 178:usbdrv/usbdrv.c ****     USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
 179:usbdrv/usbdrv.c ****     (char)0x81, /* IN endpoint number 1 */
 180:usbdrv/usbdrv.c ****     0x03,       /* attrib: Interrupt endpoint */
 181:usbdrv/usbdrv.c ****     8, 0,       /* maximum packet size */
 182:usbdrv/usbdrv.c ****     USB_CFG_INTR_POLL_INTERVAL, /* in ms */
 183:usbdrv/usbdrv.c **** #endif
 184:usbdrv/usbdrv.c **** };
 185:usbdrv/usbdrv.c **** #endif
 186:usbdrv/usbdrv.c **** 
 187:usbdrv/usbdrv.c **** /* We don't use prog_int or prog_int16_t for compatibility with various libc
 188:usbdrv/usbdrv.c ****  * versions. Here's an other compatibility hack:
 189:usbdrv/usbdrv.c ****  */
 190:usbdrv/usbdrv.c **** #ifndef PRG_RDB
 191:usbdrv/usbdrv.c **** #define PRG_RDB(addr)   pgm_read_byte(addr)
 192:usbdrv/usbdrv.c **** #endif
 193:usbdrv/usbdrv.c **** 
 194:usbdrv/usbdrv.c **** typedef union{
 195:usbdrv/usbdrv.c ****     unsigned    word;
 196:usbdrv/usbdrv.c ****     uchar       *ptr;
 197:usbdrv/usbdrv.c ****     uchar       bytes[2];
 198:usbdrv/usbdrv.c **** }converter_t;
 199:usbdrv/usbdrv.c **** /* We use this union to do type conversions. This is better optimized than
 200:usbdrv/usbdrv.c ****  * type casts in gcc 3.4.3 and much better than using bit shifts to build
 201:usbdrv/usbdrv.c ****  * ints from chars. Byte ordering is not a problem on an 8 bit platform.
 202:usbdrv/usbdrv.c ****  */
 203:usbdrv/usbdrv.c **** 
 204:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 205:usbdrv/usbdrv.c **** 
 206:usbdrv/usbdrv.c **** static inline void  usbResetDataToggling(void)
 207:usbdrv/usbdrv.c **** {
 208:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT
 209:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 210:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
 211:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 212:usbdrv/usbdrv.c **** #   endif
 213:usbdrv/usbdrv.c **** #endif
 214:usbdrv/usbdrv.c **** }
 215:usbdrv/usbdrv.c **** 
 216:usbdrv/usbdrv.c **** static inline void  usbResetStall(void)
 217:usbdrv/usbdrv.c **** {
 218:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT && USB_CFG_HAVE_INTRIN_ENDPOINT
 219:usbdrv/usbdrv.c ****         usbTxLen1 = USBPID_NAK;
 220:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 221:usbdrv/usbdrv.c ****         usbTxLen3 = USBPID_NAK;
 222:usbdrv/usbdrv.c **** #endif
 223:usbdrv/usbdrv.c **** #endif
 224:usbdrv/usbdrv.c **** }
 225:usbdrv/usbdrv.c **** 
 226:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 227:usbdrv/usbdrv.c **** 
 228:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT
 229:usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
 230:usbdrv/usbdrv.c **** {
 231:usbdrv/usbdrv.c **** uchar       *p, i;
 232:usbdrv/usbdrv.c **** 
 233:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 234:usbdrv/usbdrv.c ****     if(usbTxLen1 == USBPID_STALL)
 235:usbdrv/usbdrv.c ****         return;
 236:usbdrv/usbdrv.c **** #endif
 237:usbdrv/usbdrv.c **** #if 0   /* No runtime checks! Caller is responsible for valid data! */
 238:usbdrv/usbdrv.c ****     if(len > 8) /* interrupt transfers are limited to 8 bytes */
 239:usbdrv/usbdrv.c ****         len = 8;
 240:usbdrv/usbdrv.c **** #endif
 241:usbdrv/usbdrv.c ****     if(usbTxLen1 & 0x10){   /* packet buffer was empty */
 242:usbdrv/usbdrv.c ****         usbTxBuf1[0] ^= USBPID_DATA0 ^ USBPID_DATA1;    /* toggle token */
 243:usbdrv/usbdrv.c ****     }else{
 244:usbdrv/usbdrv.c ****         usbTxLen1 = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
 245:usbdrv/usbdrv.c ****     }
 246:usbdrv/usbdrv.c ****     p = usbTxBuf1 + 1;
 247:usbdrv/usbdrv.c ****     for(i=len;i--;)
 248:usbdrv/usbdrv.c ****         *p++ = *data++;
 249:usbdrv/usbdrv.c ****     usbCrc16Append(&usbTxBuf1[1], len);
 250:usbdrv/usbdrv.c ****     usbTxLen1 = len + 4;    /* len must be given including sync byte */
 251:usbdrv/usbdrv.c ****     DBG2(0x21, usbTxBuf1, len + 3);
 252:usbdrv/usbdrv.c **** }
 253:usbdrv/usbdrv.c **** #endif
 254:usbdrv/usbdrv.c **** 
 255:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 256:usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
 257:usbdrv/usbdrv.c **** {
 258:usbdrv/usbdrv.c **** uchar       *p, i;
 259:usbdrv/usbdrv.c **** 
 260:usbdrv/usbdrv.c ****     if(usbTxLen3 & 0x10){   /* packet buffer was empty */
 261:usbdrv/usbdrv.c ****         usbTxBuf3[0] ^= USBPID_DATA0 ^ USBPID_DATA1;    /* toggle token */
 262:usbdrv/usbdrv.c ****     }else{
 263:usbdrv/usbdrv.c ****         usbTxLen3 = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
 264:usbdrv/usbdrv.c ****     }
 265:usbdrv/usbdrv.c ****     p = usbTxBuf3 + 1;
 266:usbdrv/usbdrv.c ****     for(i=len;i--;)
 267:usbdrv/usbdrv.c ****         *p++ = *data++;
 268:usbdrv/usbdrv.c ****     usbCrc16Append(&usbTxBuf3[1], len);
 269:usbdrv/usbdrv.c ****     usbTxLen3 = len + 4;    /* len must be given including sync byte */
 270:usbdrv/usbdrv.c ****     DBG2(0x23, usbTxBuf3, len + 3);
 271:usbdrv/usbdrv.c **** }
 272:usbdrv/usbdrv.c **** #endif
 273:usbdrv/usbdrv.c **** 
 274:usbdrv/usbdrv.c **** 
 275:usbdrv/usbdrv.c **** static uchar usbRead(uchar *data, uchar len)
 276:usbdrv/usbdrv.c **** {
 277:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ
 278:usbdrv/usbdrv.c ****     if(usbMsgFlags & USB_FLG_USE_DEFAULT_RW){
 279:usbdrv/usbdrv.c **** #endif
 280:usbdrv/usbdrv.c ****         uchar i = len, *r = usbMsgPtr;
 281:usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 282:usbdrv/usbdrv.c ****             while(i--){
 283:usbdrv/usbdrv.c ****                 uchar c = PRG_RDB(r);    /* assign to char size variable to enforce byte ops */
 284:usbdrv/usbdrv.c ****                 *data++ = c;
 285:usbdrv/usbdrv.c ****                 r++;
 286:usbdrv/usbdrv.c ****             }
 287:usbdrv/usbdrv.c ****         }else{                  /* RAM data */
 288:usbdrv/usbdrv.c ****             while(i--)
 289:usbdrv/usbdrv.c ****                 *data++ = *r++;
 290:usbdrv/usbdrv.c ****         }
 291:usbdrv/usbdrv.c ****         usbMsgPtr = r;
 292:usbdrv/usbdrv.c ****         return len;
 293:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ
 294:usbdrv/usbdrv.c ****     }else{
 295:usbdrv/usbdrv.c ****         if(len != 0)    /* don't bother app with 0 sized reads */
 296:usbdrv/usbdrv.c ****             return usbFunctionRead(data, len);
 297:usbdrv/usbdrv.c ****         return 0;
 298:usbdrv/usbdrv.c ****     }
 299:usbdrv/usbdrv.c **** #endif
 300:usbdrv/usbdrv.c **** }
 301:usbdrv/usbdrv.c **** 
 302:usbdrv/usbdrv.c **** 
 303:usbdrv/usbdrv.c **** #define GET_DESCRIPTOR(cfgProp, staticName)         \
 304:usbdrv/usbdrv.c ****     if(cfgProp){                                    \
 305:usbdrv/usbdrv.c ****         if((cfgProp) & USB_PROP_IS_RAM)             \
 306:usbdrv/usbdrv.c ****             flags &= ~USB_FLG_MSGPTR_IS_ROM;        \
 307:usbdrv/usbdrv.c ****         if((cfgProp) & USB_PROP_IS_DYNAMIC){        \
 308:usbdrv/usbdrv.c ****             replyLen = usbFunctionDescriptor(rq);   \
 309:usbdrv/usbdrv.c ****         }else{                                      \
 310:usbdrv/usbdrv.c ****             replyData = (uchar *)(staticName);      \
 311:usbdrv/usbdrv.c ****             SET_REPLY_LEN((cfgProp) & 0xff);        \
 312:usbdrv/usbdrv.c ****         }                                           \
 313:usbdrv/usbdrv.c ****     }
 314:usbdrv/usbdrv.c **** /* We use if() instead of #if in the macro above because #if can't be used
 315:usbdrv/usbdrv.c ****  * in macros and the compiler optimizes constant conditions anyway.
 316:usbdrv/usbdrv.c ****  */
 317:usbdrv/usbdrv.c **** 
 318:usbdrv/usbdrv.c **** 
 319:usbdrv/usbdrv.c **** /* Don't make this function static to avoid inlining.
 320:usbdrv/usbdrv.c ****  * The entire function would become too large and exceed the range of
 321:usbdrv/usbdrv.c ****  * relative jumps.
 322:usbdrv/usbdrv.c ****  * 2006-02-25: Either gcc 3.4.3 is better than the gcc used when the comment
 323:usbdrv/usbdrv.c ****  * above was written, or other parts of the code have changed. We now get
 324:usbdrv/usbdrv.c ****  * better results with an inlined function. Test condition: PowerSwitch code.
 325:usbdrv/usbdrv.c ****  */
 326:usbdrv/usbdrv.c **** static void usbProcessRx(uchar *data, uchar len)
 327:usbdrv/usbdrv.c **** {
 328:usbdrv/usbdrv.c **** usbRequest_t    *rq = (void *)data;
 329:usbdrv/usbdrv.c **** uchar           replyLen = 0, flags = USB_FLG_USE_DEFAULT_RW;
 330:usbdrv/usbdrv.c **** /* We use if() cascades because the compare is done byte-wise while switch()
 331:usbdrv/usbdrv.c ****  * is int-based. The if() cascades are therefore more efficient.
 332:usbdrv/usbdrv.c ****  */
 333:usbdrv/usbdrv.c **** /* usbRxToken can be:
 334:usbdrv/usbdrv.c ****  * 0x2d 00101101 (USBPID_SETUP for endpoint 0)
 335:usbdrv/usbdrv.c ****  * 0xe1 11100001 (USBPID_OUT for endpoint 0)
 336:usbdrv/usbdrv.c ****  * 0xff 11111111 (USBPID_OUT for endpoint 1)
 337:usbdrv/usbdrv.c ****  */
 338:usbdrv/usbdrv.c ****     DBG2(0x10 + ((usbRxToken >> 1) & 3), data, len);    /* SETUP0=12; OUT0=10; OUT1=13 */
 339:usbdrv/usbdrv.c **** #ifdef USB_RX_USER_HOOK
 340:usbdrv/usbdrv.c ****     USB_RX_USER_HOOK(data, len)
 341:usbdrv/usbdrv.c **** #endif
 342:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_WRITEOUT
 343:usbdrv/usbdrv.c ****     if(usbRxToken < 0x10){  /* endpoint number in usbRxToken */
 344:usbdrv/usbdrv.c ****         usbFunctionWriteOut(data, len);
 345:usbdrv/usbdrv.c ****         return; /* no reply expected, hence no usbMsgPtr, usbMsgFlags, usbMsgLen set */
 346:usbdrv/usbdrv.c ****     }
 347:usbdrv/usbdrv.c **** #endif
 348:usbdrv/usbdrv.c ****     if(usbRxToken == (uchar)USBPID_SETUP){
 349:usbdrv/usbdrv.c ****         usbTxLen = USBPID_NAK;  /* abort pending transmit */
 350:usbdrv/usbdrv.c ****         if(len == 8){   /* Setup size must be always 8 bytes. Ignore otherwise. */
 351:usbdrv/usbdrv.c ****             uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
 352:usbdrv/usbdrv.c ****             if(type == USBRQ_TYPE_STANDARD){
 353:usbdrv/usbdrv.c ****                 #define SET_REPLY_LEN(len)  replyLen = (len); usbMsgPtr = replyData
 354:usbdrv/usbdrv.c ****                 /* This macro ensures that replyLen and usbMsgPtr are always set in the same way.
 355:usbdrv/usbdrv.c ****                  * That allows optimization of common code in if() branches */
 356:usbdrv/usbdrv.c ****                 uchar *replyData = usbTxBuf + 9; /* there is 3 bytes free space at the end of the b
 357:usbdrv/usbdrv.c ****                 replyData[0] = 0;   /* common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
 358:usbdrv/usbdrv.c ****                 if(rq->bRequest == USBRQ_GET_STATUS){           /* 0 */
 359:usbdrv/usbdrv.c ****                     uchar __attribute__((__unused__)) recipient = rq->bmRequestType & USBRQ_RCPT_MA
 360:usbdrv/usbdrv.c **** #if USB_CFG_IS_SELF_POWERED
 361:usbdrv/usbdrv.c ****                     if(recipient == USBRQ_RCPT_DEVICE)
 362:usbdrv/usbdrv.c ****                         replyData[0] =  USB_CFG_IS_SELF_POWERED;
 363:usbdrv/usbdrv.c **** #endif
 364:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && USB_CFG_IMPLEMENT_HALT
 365:usbdrv/usbdrv.c ****                     if(recipient == USBRQ_RCPT_ENDPOINT && rq->wIndex.bytes[0] == 0x81)   /* reques
 366:usbdrv/usbdrv.c ****                         replyData[0] = usbTxLen1 == USBPID_STALL;
 367:usbdrv/usbdrv.c **** #endif
 368:usbdrv/usbdrv.c ****                     replyData[1] = 0;
 369:usbdrv/usbdrv.c ****                     SET_REPLY_LEN(2);
 370:usbdrv/usbdrv.c ****                 }else if(rq->bRequest == USBRQ_SET_ADDRESS){    /* 5 */
 371:usbdrv/usbdrv.c ****                     usbNewDeviceAddr = rq->wValue.bytes[0];
 372:usbdrv/usbdrv.c **** #ifdef USB_SET_ADDRESS_HOOK
 373:usbdrv/usbdrv.c ****                     USB_SET_ADDRESS_HOOK();
 374:usbdrv/usbdrv.c **** #endif
 375:usbdrv/usbdrv.c ****                 }else if(rq->bRequest == USBRQ_GET_DESCRIPTOR){ /* 6 */
 376:usbdrv/usbdrv.c ****                     flags = USB_FLG_MSGPTR_IS_ROM | USB_FLG_USE_DEFAULT_RW;
 377:usbdrv/usbdrv.c ****                     if(rq->wValue.bytes[1] == USBDESCR_DEVICE){ /* 1 */
 378:usbdrv/usbdrv.c ****                         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
 379:usbdrv/usbdrv.c ****                     }else if(rq->wValue.bytes[1] == USBDESCR_CONFIG){   /* 2 */
 380:usbdrv/usbdrv.c ****                         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguratio
 381:usbdrv/usbdrv.c ****                     }else if(rq->wValue.bytes[1] == USBDESCR_STRING){   /* 3 */
 382:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
 383:usbdrv/usbdrv.c ****                         if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
 384:usbdrv/usbdrv.c ****                             flags &= ~USB_FLG_MSGPTR_IS_ROM;
 385:usbdrv/usbdrv.c ****                         replyLen = usbFunctionDescriptor(rq);
 386:usbdrv/usbdrv.c **** #else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
 387:usbdrv/usbdrv.c ****                         if(rq->wValue.bytes[0] == 0){   /* descriptor index */
 388:usbdrv/usbdrv.c ****                             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
 389:usbdrv/usbdrv.c ****                         }else if(rq->wValue.bytes[0] == 1){
 390:usbdrv/usbdrv.c ****                             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVe
 391:usbdrv/usbdrv.c ****                         }else if(rq->wValue.bytes[0] == 2){
 392:usbdrv/usbdrv.c ****                             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringD
 393:usbdrv/usbdrv.c ****                         }else if(rq->wValue.bytes[0] == 3){
 394:usbdrv/usbdrv.c ****                             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER, usbDescriptorS
 395:usbdrv/usbdrv.c ****                         }else if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
 396:usbdrv/usbdrv.c ****                             replyLen = usbFunctionDescriptor(rq);
 397:usbdrv/usbdrv.c ****                         }
 398:usbdrv/usbdrv.c **** #endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
 399:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
 400:usbdrv/usbdrv.c ****                     }else if(rq->wValue.bytes[1] == USBDESCR_HID){          /* 0x21 */
 401:usbdrv/usbdrv.c ****                         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
 402:usbdrv/usbdrv.c ****                     }else if(rq->wValue.bytes[1] == USBDESCR_HID_REPORT){   /* 0x22 */
 403:usbdrv/usbdrv.c ****                         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
 404:usbdrv/usbdrv.c **** #endif  /* USB_CFG_DESCR_PROPS_HID_REPORT */
 405:usbdrv/usbdrv.c ****                     }else if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
 406:usbdrv/usbdrv.c ****                         replyLen = usbFunctionDescriptor(rq);
 407:usbdrv/usbdrv.c ****                     }
 408:usbdrv/usbdrv.c ****                 }else if(rq->bRequest == USBRQ_GET_CONFIGURATION){  /* 8 */
 409:usbdrv/usbdrv.c ****                     replyData = &usbConfiguration;  /* send current configuration value */
 410:usbdrv/usbdrv.c ****                     SET_REPLY_LEN(1);
 411:usbdrv/usbdrv.c ****                 }else if(rq->bRequest == USBRQ_SET_CONFIGURATION){  /* 9 */
 412:usbdrv/usbdrv.c ****                     usbConfiguration = rq->wValue.bytes[0];
 413:usbdrv/usbdrv.c ****                     usbResetStall();
 414:usbdrv/usbdrv.c ****                 }else if(rq->bRequest == USBRQ_GET_INTERFACE){      /* 10 */
 415:usbdrv/usbdrv.c ****                     SET_REPLY_LEN(1);
 416:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT
 417:usbdrv/usbdrv.c ****                 }else if(rq->bRequest == USBRQ_SET_INTERFACE){      /* 11 */
 418:usbdrv/usbdrv.c ****                     usbResetDataToggling();
 419:usbdrv/usbdrv.c ****                     usbResetStall();
 420:usbdrv/usbdrv.c **** #   if USB_CFG_IMPLEMENT_HALT
 421:usbdrv/usbdrv.c ****                 }else if(rq->bRequest == USBRQ_CLEAR_FEATURE || rq->bRequest == USBRQ_SET_FEATURE){
 422:usbdrv/usbdrv.c ****                     if(rq->wValue.bytes[0] == 0 && rq->wIndex.bytes[0] == 0x81){   /* feature 0 == 
 423:usbdrv/usbdrv.c ****                         usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL
 424:usbdrv/usbdrv.c ****                         usbResetDataToggling();
 425:usbdrv/usbdrv.c ****                     }
 426:usbdrv/usbdrv.c **** #   endif
 427:usbdrv/usbdrv.c **** #endif
 428:usbdrv/usbdrv.c ****                 }else{
 429:usbdrv/usbdrv.c ****                     /* the following requests can be ignored, send default reply */
 430:usbdrv/usbdrv.c ****                     /* 1: CLEAR_FEATURE, 3: SET_FEATURE, 7: SET_DESCRIPTOR */
 431:usbdrv/usbdrv.c ****                     /* 12: SYNCH_FRAME */
 432:usbdrv/usbdrv.c ****                 }
 433:usbdrv/usbdrv.c ****                 #undef SET_REPLY_LEN
 434:usbdrv/usbdrv.c ****             }else{  /* not a standard request -- must be vendor or class request */
 435:usbdrv/usbdrv.c ****                 replyLen = usbFunctionSetup(data);
 436:usbdrv/usbdrv.c ****             }
 437:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE
 438:usbdrv/usbdrv.c ****             if(replyLen == 0xff){   /* use user-supplied read/write function */
 439:usbdrv/usbdrv.c ****                 if((rq->bmRequestType & USBRQ_DIR_MASK) == USBRQ_DIR_DEVICE_TO_HOST){
 440:usbdrv/usbdrv.c ****                     replyLen = rq->wLength.bytes[0];    /* IN transfers only */
 441:usbdrv/usbdrv.c ****                 }
 442:usbdrv/usbdrv.c ****                 flags &= ~USB_FLG_USE_DEFAULT_RW;  /* we have no valid msg, use user supplied read/
 443:usbdrv/usbdrv.c ****             }else   /* The 'else' prevents that we limit a replyLen of 0xff to the maximum transfer
 444:usbdrv/usbdrv.c **** #endif
 445:usbdrv/usbdrv.c ****             if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])  /* limit length to max */
 446:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.bytes[0];
 447:usbdrv/usbdrv.c ****         }
 448:usbdrv/usbdrv.c ****         /* make sure that data packets which are sent as ACK to an OUT transfer are always zero siz
 449:usbdrv/usbdrv.c ****     }else{  /* DATA packet from out request */
 450:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_WRITE
 451:usbdrv/usbdrv.c ****         if(!(usbMsgFlags & USB_FLG_USE_DEFAULT_RW)){
 452:usbdrv/usbdrv.c ****             uchar rval = usbFunctionWrite(data, len);
 453:usbdrv/usbdrv.c ****             replyLen = 0xff;
 454:usbdrv/usbdrv.c ****             if(rval == 0xff){       /* an error occurred */
 455:usbdrv/usbdrv.c ****                 usbMsgLen = 0xff;   /* cancel potentially pending data packet for ACK */
 456:usbdrv/usbdrv.c ****                 usbTxLen = USBPID_STALL;
 457:usbdrv/usbdrv.c ****             }else if(rval != 0){    /* This was the final package */
 458:usbdrv/usbdrv.c ****                 replyLen = 0;       /* answer with a zero-sized data packet */
 459:usbdrv/usbdrv.c ****             }
 460:usbdrv/usbdrv.c ****             flags = 0;    /* start with a DATA1 package, stay with user supplied write() function *
 461:usbdrv/usbdrv.c ****         }
 462:usbdrv/usbdrv.c **** #endif
 463:usbdrv/usbdrv.c ****     }
 464:usbdrv/usbdrv.c ****     usbMsgFlags = flags;
 465:usbdrv/usbdrv.c ****     usbMsgLen = replyLen;
 466:usbdrv/usbdrv.c **** }
 467:usbdrv/usbdrv.c **** 
 468:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 469:usbdrv/usbdrv.c **** 
 470:usbdrv/usbdrv.c **** static void usbBuildTxBlock(void)
 471:usbdrv/usbdrv.c **** {
 472:usbdrv/usbdrv.c **** uchar   wantLen, len, txLen, token;
 473:usbdrv/usbdrv.c **** 
 474:usbdrv/usbdrv.c ****     wantLen = usbMsgLen;
 475:usbdrv/usbdrv.c ****     if(wantLen > 8)
 476:usbdrv/usbdrv.c ****         wantLen = 8;
 477:usbdrv/usbdrv.c ****     usbMsgLen -= wantLen;
 478:usbdrv/usbdrv.c ****     token = USBPID_DATA1;
 479:usbdrv/usbdrv.c ****     if(usbMsgFlags & USB_FLG_TX_PACKET)
 480:usbdrv/usbdrv.c ****         token = USBPID_DATA0;
 481:usbdrv/usbdrv.c ****     usbMsgFlags++;
 482:usbdrv/usbdrv.c ****     len = usbRead(usbTxBuf + 1, wantLen);
 483:usbdrv/usbdrv.c ****     if(len <= 8){           /* valid data packet */
 484:usbdrv/usbdrv.c ****         usbCrc16Append(&usbTxBuf[1], len);
 485:usbdrv/usbdrv.c ****         txLen = len + 4;    /* length including sync byte */
 486:usbdrv/usbdrv.c ****         if(len < 8)         /* a partial package identifies end of message */
 487:usbdrv/usbdrv.c ****             usbMsgLen = 0xff;
 488:usbdrv/usbdrv.c ****     }else{
 489:usbdrv/usbdrv.c ****         txLen = USBPID_STALL;   /* stall the endpoint */
 490:usbdrv/usbdrv.c ****         usbMsgLen = 0xff;
 491:usbdrv/usbdrv.c ****     }
 492:usbdrv/usbdrv.c ****     usbTxBuf[0] = token;
 493:usbdrv/usbdrv.c ****     usbTxLen = txLen;
 494:usbdrv/usbdrv.c ****     DBG2(0x20, usbTxBuf, txLen-1);
 495:usbdrv/usbdrv.c **** }
 496:usbdrv/usbdrv.c **** 
 497:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 498:usbdrv/usbdrv.c **** 
 499:usbdrv/usbdrv.c **** static inline uchar isNotSE0(void)
 500:usbdrv/usbdrv.c **** {
 501:usbdrv/usbdrv.c **** uchar   rval;
 502:usbdrv/usbdrv.c **** /* We want to do
 503:usbdrv/usbdrv.c ****  *     return (USBIN & USBMASK);
 504:usbdrv/usbdrv.c ****  * here, but the compiler does int-expansion acrobatics.
 505:usbdrv/usbdrv.c ****  * We can avoid this by assigning to a char-sized variable.
 506:usbdrv/usbdrv.c ****  */
 507:usbdrv/usbdrv.c ****     rval = USBIN & USBMASK;
 508:usbdrv/usbdrv.c ****     return rval;
 509:usbdrv/usbdrv.c **** }
 510:usbdrv/usbdrv.c **** 
 511:usbdrv/usbdrv.c **** static inline void usbHandleResetHook(uchar notResetState)
 512:usbdrv/usbdrv.c **** {
 513:usbdrv/usbdrv.c **** #ifdef USB_RESET_HOOK
 514:usbdrv/usbdrv.c **** static uchar    wasReset;
 515:usbdrv/usbdrv.c **** uchar           isReset = !notResetState;
 516:usbdrv/usbdrv.c **** 
 517:usbdrv/usbdrv.c ****     if(wasReset != isReset){
 518:usbdrv/usbdrv.c ****         USB_RESET_HOOK(isReset);
 519:usbdrv/usbdrv.c ****         wasReset = isReset;
 520:usbdrv/usbdrv.c ****     }
 521:usbdrv/usbdrv.c **** #endif
 522:usbdrv/usbdrv.c **** }
 523:usbdrv/usbdrv.c **** 
 524:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 525:usbdrv/usbdrv.c **** 
 526:usbdrv/usbdrv.c **** USB_PUBLIC void usbPoll(void)
 527:usbdrv/usbdrv.c **** {
 528:usbdrv/usbdrv.c **** schar   len;
 529:usbdrv/usbdrv.c **** uchar   i;
 530:usbdrv/usbdrv.c **** 
 531:usbdrv/usbdrv.c ****     if((len = usbRxLen) > 0){
 532:usbdrv/usbdrv.c **** /* We could check CRC16 here -- but ACK has already been sent anyway. If you
 533:usbdrv/usbdrv.c ****  * need data integrity checks with this driver, check the CRC in your app
 534:usbdrv/usbdrv.c ****  * code and report errors back to the host. Since the ACK was already sent,
 535:usbdrv/usbdrv.c ****  * retries must be handled on application level.
 536:usbdrv/usbdrv.c ****  * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 537:usbdrv/usbdrv.c ****  */
 538:usbdrv/usbdrv.c ****         usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len - 3);
 539:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_FLOWCONTROL
 540:usbdrv/usbdrv.c ****         if(usbRxLen > 0)    /* only mark as available if not inactivated */
 541:usbdrv/usbdrv.c ****             usbRxLen = 0;
 542:usbdrv/usbdrv.c **** #else
 543:usbdrv/usbdrv.c ****         usbRxLen = 0;       /* mark rx buffer as available */
 544:usbdrv/usbdrv.c **** #endif
 545:usbdrv/usbdrv.c ****     }
 546:usbdrv/usbdrv.c ****     if(usbTxLen & 0x10){ /* transmit system idle */
 547:usbdrv/usbdrv.c ****         if(usbMsgLen != 0xff){  /* transmit data pending? */
 548:usbdrv/usbdrv.c ****             usbBuildTxBlock();
 549:usbdrv/usbdrv.c ****         }
 550:usbdrv/usbdrv.c ****     }
 551:usbdrv/usbdrv.c ****     for(i = 10; i > 0; i--){
 552:usbdrv/usbdrv.c ****         if(isNotSE0())
 553:usbdrv/usbdrv.c ****             break;
 554:usbdrv/usbdrv.c ****     }
 555:usbdrv/usbdrv.c ****     if(i == 0){ /* RESET condition, called multiple times during reset */
 556:usbdrv/usbdrv.c ****         usbNewDeviceAddr = 0;
 557:usbdrv/usbdrv.c ****         usbDeviceAddr = 0;
 558:usbdrv/usbdrv.c ****         usbResetStall();
 559:usbdrv/usbdrv.c ****         DBG1(0xff, 0, 0);
 560:usbdrv/usbdrv.c ****     }
 561:usbdrv/usbdrv.c ****     usbHandleResetHook(i);
 562:usbdrv/usbdrv.c **** }
 563:usbdrv/usbdrv.c **** 
 564:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 565:usbdrv/usbdrv.c **** 
 566:usbdrv/usbdrv.c **** USB_PUBLIC void usbInit(void)
 567:usbdrv/usbdrv.c **** {
  99               	.LM0:
 100               	.LFBB1:
 101               	/* prologue: frame size=0 */
 102               	/* prologue end (size=0) */
 568:usbdrv/usbdrv.c **** #if USB_INTR_CFG_SET != 0
 569:usbdrv/usbdrv.c ****     USB_INTR_CFG |= USB_INTR_CFG_SET;
 104               	.LM1:
 105 0000 E9E6      		ldi r30,lo8(105)
 106 0002 F0E0      		ldi r31,hi8(105)
 107 0004 8081      		ld r24,Z
 108 0006 8360      		ori r24,lo8(3)
 109 0008 8083      		st Z,r24
 570:usbdrv/usbdrv.c **** #endif
 571:usbdrv/usbdrv.c **** #if USB_INTR_CFG_CLR != 0
 572:usbdrv/usbdrv.c ****     USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
 573:usbdrv/usbdrv.c **** #endif
 574:usbdrv/usbdrv.c ****     USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
 111               	.LM2:
 112 000a E89A      		sbi 61-0x20,0
 113               	/* epilogue: frame size=0 */
 114 000c 0895      		ret
 115               	/* epilogue end (size=1) */
 116               	/* function usbInit size 7 (6) */
 118               	.Lscope1:
 120               		.stabd	78,0,0
 122               	.global	usbPoll
 124               	usbPoll:
 125               		.stabd	46,0,0
 127               	.LM3:
 128               	.LFBB2:
 129               	/* prologue: frame size=0 */
 130 000e 0F93      		push r16
 131 0010 1F93      		push r17
 132 0012 CF93      		push r28
 133 0014 DF93      		push r29
 134               	/* prologue end (size=4) */
 136               	.LM4:
 137 0016 6091 0000 		lds r22,usbRxLen
 138 001a 1616      		cp __zero_reg__,r22
 139 001c 04F0      		brlt .+2
 140 001e 00C0      		rjmp .L4
 142               	.LM5:
 143 0020 6350      		subi r22,lo8(-(-3))
 144 0022 8091 0000 		lds r24,usbInputBufOffset
 145 0026 C0E0      		ldi r28,lo8(usbRxBuf+12)
 146 0028 D0E0      		ldi r29,hi8(usbRxBuf+12)
 147 002a C81B      		sub r28,r24
 148 002c D109      		sbc r29,__zero_reg__
 149               	.LBB31:
 150               	.LBB32:
 152               	.LM6:
 153 002e 8091 0000 		lds r24,usbRxToken
 154 0032 8D32      		cpi r24,lo8(45)
 155 0034 01F0      		breq .+2
 156 0036 00C0      		rjmp .L6
 158               	.LM7:
 159 0038 8AE5      		ldi r24,lo8(90)
 160 003a 8093 0000 		sts usbTxLen,r24
 162               	.LM8:
 163 003e 6830      		cpi r22,lo8(8)
 164 0040 01F0      		breq .+2
 165 0042 00C0      		rjmp .L8
 166               	.LBB34:
 168               	.LM9:
 169 0044 8881      		ld r24,Y
 170 0046 8076      		andi r24,lo8(96)
 171 0048 01F0      		breq .+2
 172 004a 00C0      		rjmp .L10
 173               	.LBB35:
 175               	.LM10:
 176 004c 20E0      		ldi r18,lo8(usbTxBuf+9)
 177 004e 30E0      		ldi r19,hi8(usbTxBuf+9)
 178 0050 1092 0000 		sts usbTxBuf+9,__zero_reg__
 180               	.LM11:
 181 0054 8981      		ldd r24,Y+1
 182 0056 8823      		tst r24
 183 0058 01F4      		brne .L12
 184               	.LBB36:
 186               	.LM12:
 187 005a 1092 0000 		sts usbTxBuf+10,__zero_reg__
 189               	.LM13:
 190 005e 3093 0000 		sts (usbMsgPtr)+1,r19
 191 0062 2093 0000 		sts usbMsgPtr,r18
 192 0066 92E0      		ldi r25,lo8(2)
 193 0068 00C0      		rjmp .L36
 194               	.L12:
 195               	.LBE36:
 197               	.LM14:
 198 006a 8530      		cpi r24,lo8(5)
 199 006c 01F4      		brne .L15
 201               	.LM15:
 202 006e 8A81      		ldd r24,Y+2
 203 0070 8093 0000 		sts usbNewDeviceAddr,r24
 204 0074 00C0      		rjmp .L34
 205               	.L15:
 207               	.LM16:
 208 0076 8630      		cpi r24,lo8(6)
 209 0078 01F4      		brne .L17
 211               	.LM17:
 212 007a 8B81      		ldd r24,Y+3
 213 007c 8130      		cpi r24,lo8(1)
 214 007e 01F4      		brne .L19
 216               	.LM18:
 217 0080 80E0      		ldi r24,lo8(usbDescriptorDevice)
 218 0082 90E0      		ldi r25,hi8(usbDescriptorDevice)
 219 0084 00C0      		rjmp .L83
 220               	.L19:
 222               	.LM19:
 223 0086 8230      		cpi r24,lo8(2)
 224 0088 01F4      		brne .L21
 226               	.LM20:
 227 008a 80E0      		ldi r24,lo8(usbDescriptorConfiguration)
 228 008c 90E0      		ldi r25,hi8(usbDescriptorConfiguration)
 229               	.L83:
 230 008e 9093 0000 		sts (usbMsgPtr)+1,r25
 231 0092 8093 0000 		sts usbMsgPtr,r24
 232 0096 92E1      		ldi r25,lo8(18)
 233 0098 00C0      		rjmp .L80
 234               	.L21:
 236               	.LM21:
 237 009a 8330      		cpi r24,lo8(3)
 238 009c 01F0      		breq .+2
 239 009e 00C0      		rjmp .L23
 241               	.LM22:
 242 00a0 8A81      		ldd r24,Y+2
 243 00a2 8823      		tst r24
 244 00a4 01F4      		brne .L25
 246               	.LM23:
 247 00a6 80E0      		ldi r24,lo8(usbDescriptorString0)
 248 00a8 90E0      		ldi r25,hi8(usbDescriptorString0)
 249 00aa 9093 0000 		sts (usbMsgPtr)+1,r25
 250 00ae 8093 0000 		sts usbMsgPtr,r24
 251 00b2 94E0      		ldi r25,lo8(4)
 252 00b4 00C0      		rjmp .L80
 253               	.L25:
 255               	.LM24:
 256 00b6 8130      		cpi r24,lo8(1)
 257 00b8 01F4      		brne .L27
 259               	.LM25:
 260 00ba 80E0      		ldi r24,lo8(usbDescriptorStringVendor)
 261 00bc 90E0      		ldi r25,hi8(usbDescriptorStringVendor)
 262 00be 9093 0000 		sts (usbMsgPtr)+1,r25
 263 00c2 8093 0000 		sts usbMsgPtr,r24
 264 00c6 9EE1      		ldi r25,lo8(30)
 265 00c8 00C0      		rjmp .L80
 266               	.L27:
 268               	.LM26:
 269 00ca 8230      		cpi r24,lo8(2)
 270 00cc 01F0      		breq .+2
 271 00ce 00C0      		rjmp .L23
 273               	.LM27:
 274 00d0 80E0      		ldi r24,lo8(usbDescriptorStringDevice)
 275 00d2 90E0      		ldi r25,hi8(usbDescriptorStringDevice)
 276 00d4 9093 0000 		sts (usbMsgPtr)+1,r25
 277 00d8 8093 0000 		sts usbMsgPtr,r24
 278 00dc 9CE0      		ldi r25,lo8(12)
 279 00de 00C0      		rjmp .L80
 280               	.L17:
 282               	.LM28:
 283 00e0 8830      		cpi r24,lo8(8)
 284 00e2 01F4      		brne .L30
 286               	.LM29:
 287 00e4 80E0      		ldi r24,lo8(usbConfiguration)
 288 00e6 90E0      		ldi r25,hi8(usbConfiguration)
 289 00e8 9093 0000 		sts (usbMsgPtr)+1,r25
 290 00ec 8093 0000 		sts usbMsgPtr,r24
 291 00f0 00C0      		rjmp .L84
 292               	.L30:
 294               	.LM30:
 295 00f2 8930      		cpi r24,lo8(9)
 296 00f4 01F4      		brne .L32
 298               	.LM31:
 299 00f6 8A81      		ldd r24,Y+2
 300 00f8 8093 0000 		sts usbConfiguration,r24
 301 00fc 00C0      		rjmp .L34
 302               	.L32:
 304               	.LM32:
 305 00fe 8A30      		cpi r24,lo8(10)
 306 0100 01F0      		breq .+2
 307 0102 00C0      		rjmp .L34
 309               	.LM33:
 310 0104 3093 0000 		sts (usbMsgPtr)+1,r19
 311 0108 2093 0000 		sts usbMsgPtr,r18
 312               	.L84:
 313 010c 91E0      		ldi r25,lo8(1)
 314 010e 00C0      		rjmp .L36
 315               	.L10:
 316               	.LBE35:
 317               	.LBE34:
 318               	.LBE32:
 320               	.LM34:
 321 0110 CE01      		movw r24,r28
 322 0112 0E94 0000 		call usbFunctionSetup
 323 0116 982F      		mov r25,r24
 324               	.LBB38:
 325               	.LBB33:
 327               	.LM35:
 328 0118 8F3F      		cpi r24,lo8(-1)
 329 011a 01F4      		brne .L36
 331               	.LM36:
 332 011c 8881      		ld r24,Y
 333 011e 87FF      		sbrs r24,7
 334 0120 00C0      		rjmp .L81
 336               	.LM37:
 337 0122 9E81      		ldd r25,Y+6
 338 0124 00C0      		rjmp .L81
 339               	.L36:
 340 0126 20E8      		ldi r18,lo8(-128)
 341               	.L14:
 343               	.LM38:
 344 0128 8F81      		ldd r24,Y+7
 345 012a 8823      		tst r24
 346 012c 01F4      		brne .L40
 347 012e 8E81      		ldd r24,Y+6
 348 0130 8917      		cp r24,r25
 349 0132 00F4      		brsh .L40
 350 0134 982F      		mov r25,r24
 351 0136 00C0      		rjmp .L40
 352               	.L6:
 353               	.LBE33:
 355               	.LM39:
 356 0138 8091 0000 		lds r24,usbMsgFlags
 357 013c 87FD      		sbrc r24,7
 358 013e 00C0      		rjmp .L8
 359               	.LBE38:
 361               	.LM40:
 362 0140 CE01      		movw r24,r28
 363 0142 0E94 0000 		call usbFunctionWrite
 364               	.LBB39:
 365               	.LBB37:
 367               	.LM41:
 368 0146 8F3F      		cpi r24,lo8(-1)
 369 0148 01F4      		brne .L44
 371               	.LM42:
 372 014a 8093 0000 		sts usbMsgLen,r24
 374               	.LM43:
 375 014e 8EE1      		ldi r24,lo8(30)
 376 0150 8093 0000 		sts usbTxLen,r24
 377 0154 00C0      		rjmp .L46
 378               	.L44:
 380               	.LM44:
 381 0156 8823      		tst r24
 382 0158 01F0      		breq .L46
 383 015a 90E0      		ldi r25,lo8(0)
 384               	.L81:
 385 015c 20E0      		ldi r18,lo8(0)
 386 015e 00C0      		rjmp .L40
 387               	.L46:
 388 0160 9FEF      		ldi r25,lo8(-1)
 389 0162 00C0      		rjmp .L81
 390               	.L8:
 391 0164 90E0      		ldi r25,lo8(0)
 392 0166 20E8      		ldi r18,lo8(-128)
 393               	.L40:
 394               	.LBE37:
 396               	.LM45:
 397 0168 2093 0000 		sts usbMsgFlags,r18
 399               	.LM46:
 400 016c 9093 0000 		sts usbMsgLen,r25
 401               	.LBE39:
 402               	.LBE31:
 404               	.LM47:
 405 0170 1092 0000 		sts usbRxLen,__zero_reg__
 406               	.L4:
 408               	.LM48:
 409 0174 8091 0000 		lds r24,usbTxLen
 410 0178 84FF      		sbrs r24,4
 411 017a 00C0      		rjmp .L48
 413               	.LM49:
 414 017c 8091 0000 		lds r24,usbMsgLen
 415 0180 8F3F      		cpi r24,lo8(-1)
 416 0182 01F4      		brne .+2
 417 0184 00C0      		rjmp .L48
 418 0186 682F      		mov r22,r24
 419 0188 8930      		cpi r24,lo8(9)
 420 018a 00F0      		brlo .L51
 421 018c 68E0      		ldi r22,lo8(8)
 422               	.L51:
 423               	.LBB40:
 424               	.LBB41:
 426               	.LM50:
 427 018e 861B      		sub r24,r22
 428 0190 8093 0000 		sts usbMsgLen,r24
 430               	.LM51:
 431 0194 8091 0000 		lds r24,usbMsgFlags
 432               	.LBE41:
 433 0198 80FF      		sbrs r24,0
 434 019a 00C0      		rjmp .L52
 435 019c 03EC      		ldi r16,lo8(-61)
 436 019e 00C0      		rjmp .L54
 437               	.L52:
 438 01a0 0BE4      		ldi r16,lo8(75)
 439               	.L54:
 440               	.LBB48:
 442               	.LM52:
 443 01a2 8F5F      		subi r24,lo8(-(1))
 444 01a4 8093 0000 		sts usbMsgFlags,r24
 445               	.LBB42:
 446               	.LBB43:
 448               	.LM53:
 449 01a8 87FF      		sbrs r24,7
 450 01aa 00C0      		rjmp .L55
 451               	.LBB44:
 453               	.LM54:
 454 01ac 2091 0000 		lds r18,usbMsgPtr
 455 01b0 3091 0000 		lds r19,(usbMsgPtr)+1
 457               	.LM55:
 458 01b4 86FD      		sbrc r24,6
 459 01b6 00C0      		rjmp .L57
 460 01b8 F901      		movw r30,r18
 461 01ba 962F      		mov r25,r22
 462 01bc A0E0      		ldi r26,lo8(usbTxBuf+1)
 463 01be B0E0      		ldi r27,hi8(usbTxBuf+1)
 464 01c0 00C0      		rjmp .L59
 465               	.L57:
 466 01c2 F901      		movw r30,r18
 467 01c4 962F      		mov r25,r22
 468 01c6 A0E0      		ldi r26,lo8(usbTxBuf+1)
 469 01c8 B0E0      		ldi r27,hi8(usbTxBuf+1)
 470 01ca 00C0      		rjmp .L60
 471               	.L61:
 472               	.LBB45:
 473               	.LBB46:
 475               	.LM56:
 476               	/* #APP */
 477 01cc 8491      		lpm r24, Z
 478               		
 479               	/* #NOAPP */
 480               	.LBE46:
 482               	.LM57:
 483 01ce 8D93      		st X+,r24
 485               	.LM58:
 486 01d0 3196      		adiw r30,1
 487               	.L60:
 488               	.LBE45:
 490               	.LM59:
 491 01d2 9150      		subi r25,1
 492 01d4 00F4      		brcc .L61
 493 01d6 00C0      		rjmp .L82
 494               	.L64:
 496               	.LM60:
 497 01d8 8191      		ld r24,Z+
 498 01da 8D93      		st X+,r24
 499               	.L59:
 501               	.LM61:
 502 01dc 9150      		subi r25,1
 503 01de 00F4      		brcc .L64
 504               	.L82:
 505 01e0 C901      		movw r24,r18
 506 01e2 860F      		add r24,r22
 507 01e4 911D      		adc r25,__zero_reg__
 509               	.LM62:
 510 01e6 9093 0000 		sts (usbMsgPtr)+1,r25
 511 01ea 8093 0000 		sts usbMsgPtr,r24
 513               	.LM63:
 514 01ee 7727      		clr r23
 515 01f0 00C0      		rjmp .L66
 516               	.L55:
 517               	.LBE44:
 519               	.LM64:
 520 01f2 6623      		tst r22
 521 01f4 01F4      		brne .L67
 522 01f6 60E0      		ldi r22,lo8(0)
 523 01f8 70E0      		ldi r23,hi8(0)
 524 01fa 00C0      		rjmp .L66
 525               	.L67:
 526               	.LBE43:
 528               	.LM65:
 529 01fc 80E0      		ldi r24,lo8(usbTxBuf+1)
 530 01fe 90E0      		ldi r25,hi8(usbTxBuf+1)
 531 0200 0E94 0000 		call usbFunctionRead
 532               	.LBB47:
 533 0204 682F      		mov r22,r24
 534 0206 7727      		clr r23
 535               	.L66:
 536               	.LBE47:
 537               	.LBE42:
 539               	.LM66:
 540 0208 162F      		mov r17,r22
 542               	.LM67:
 543 020a 6930      		cpi r22,lo8(9)
 544 020c 00F4      		brsh .L69
 546               	.LM68:
 547 020e 80E0      		ldi r24,lo8(usbTxBuf+1)
 548 0210 90E0      		ldi r25,hi8(usbTxBuf+1)
 549 0212 0E94 0000 		call usbCrc16Append
 551               	.LM69:
 552 0216 912F      		mov r25,r17
 553 0218 9C5F      		subi r25,lo8(-(4))
 555               	.LM70:
 556 021a 1830      		cpi r17,lo8(8)
 557 021c 01F0      		breq .L71
 559               	.LM71:
 560 021e 8FEF      		ldi r24,lo8(-1)
 561 0220 8093 0000 		sts usbMsgLen,r24
 562 0224 00C0      		rjmp .L71
 563               	.L69:
 565               	.LM72:
 566 0226 8FEF      		ldi r24,lo8(-1)
 567 0228 8093 0000 		sts usbMsgLen,r24
 568 022c 9EE1      		ldi r25,lo8(30)
 569               	.L71:
 571               	.LM73:
 572 022e 0093 0000 		sts usbTxBuf,r16
 574               	.LM74:
 575 0232 9093 0000 		sts usbTxLen,r25
 576               	.L48:
 577 0236 9AE0      		ldi r25,lo8(10)
 578               	.L73:
 579               	.LBE48:
 580               	.LBE40:
 581               	.LBB49:
 582               	.LBB50:
 584               	.LM75:
 585 0238 89B1      		in r24,41-0x20
 586               	.LBE50:
 587               	.LBE49:
 589               	.LM76:
 590 023a 8471      		andi r24,lo8(20)
 591 023c 01F4      		brne .L77
 593               	.LM77:
 594 023e 9150      		subi r25,lo8(-(-1))
 595 0240 01F4      		brne .L73
 597               	.LM78:
 598 0242 1092 0000 		sts usbNewDeviceAddr,__zero_reg__
 600               	.LM79:
 601 0246 1092 0000 		sts usbDeviceAddr,__zero_reg__
 602 024a 00C0      		rjmp .L77
 603               	.L34:
 605               	.LM80:
 606 024c 90E0      		ldi r25,lo8(0)
 607 024e 00C0      		rjmp .L36
 608               	.L23:
 609 0250 90E0      		ldi r25,lo8(0)
 610               	.L80:
 611 0252 20EC      		ldi r18,lo8(-64)
 612 0254 00C0      		rjmp .L14
 613               	.L77:
 614               	/* epilogue: frame size=0 */
 615 0256 DF91      		pop r29
 616 0258 CF91      		pop r28
 617 025a 1F91      		pop r17
 618 025c 0F91      		pop r16
 619 025e 0895      		ret
 620               	/* epilogue end (size=5) */
 621               	/* function usbPoll size 305 (296) */
 649               	.Lscope2:
 651               		.stabd	78,0,0
 652               	.global	usbMsgLen
 653               		.data
 656               	usbMsgLen:
 657 0000 FF        		.byte	-1
 658               	.global	usbTxLen
 661               	usbTxLen:
 662 0001 5A        		.byte	90
 663               	.global	usbDescriptorString0
 664               		.section	.progmem.data,"a",@progbits
 667               	usbDescriptorString0:
 668 0000 04        		.byte	4
 669 0001 03        		.byte	3
 670 0002 09        		.byte	9
 671 0003 04        		.byte	4
 672               	.global	usbDescriptorStringVendor
 675               	usbDescriptorStringVendor:
 676 0004 1E03      		.word	798
 677 0006 6C00      		.word	108
 678 0008 6F00      		.word	111
 679 000a 6300      		.word	99
 680 000c 6800      		.word	104
 681 000e 7200      		.word	114
 682 0010 6100      		.word	97
 683 0012 7300      		.word	115
 684 0014 7400      		.word	116
 685 0016 6500      		.word	101
 686 0018 7200      		.word	114
 687 001a 2E00      		.word	46
 688 001c 6F00      		.word	111
 689 001e 7200      		.word	114
 690 0020 6700      		.word	103
 691               	.global	usbDescriptorStringDevice
 694               	usbDescriptorStringDevice:
 695 0022 0C03      		.word	780
 696 0024 7500      		.word	117
 697 0026 6E00      		.word	110
 698 0028 7A00      		.word	122
 699 002a 6100      		.word	97
 700 002c 7000      		.word	112
 701               	.global	usbDescriptorDevice
 704               	usbDescriptorDevice:
 705 002e 12        		.byte	18
 706 002f 01        		.byte	1
 707 0030 10        		.byte	16
 708 0031 01        		.byte	1
 709 0032 FF        		.byte	-1
 710 0033 00        		.byte	0
 711 0034 00        		.byte	0
 712 0035 08        		.byte	8
 713 0036 C0        		.byte	-64
 714 0037 16        		.byte	22
 715 0038 2E        		.byte	46
 716 0039 28        		.byte	40
 717 003a 00        		.byte	0
 718 003b 01        		.byte	1
 719 003c 01        		.byte	1
 720 003d 02        		.byte	2
 721 003e 00        		.byte	0
 722 003f 01        		.byte	1
 723               	.global	usbDescriptorConfiguration
 726               	usbDescriptorConfiguration:
 727 0040 09        		.byte	9
 728 0041 02        		.byte	2
 729 0042 12        		.byte	18
 730 0043 00        		.byte	0
 731 0044 01        		.byte	1
 732 0045 01        		.byte	1
 733 0046 00        		.byte	0
 734 0047 80        		.byte	-128
 735 0048 32        		.byte	50
 736 0049 09        		.byte	9
 737 004a 04        		.byte	4
 738 004b 00        		.byte	0
 739 004c 00        		.byte	0
 740 004d 00        		.byte	0
 741 004e 00        		.byte	0
 742 004f 00        		.byte	0
 743 0050 00        		.byte	0
 744 0051 00        		.byte	0
 745               		.lcomm usbMsgFlags,1
 746               		.comm usbMsgPtr,2,1
 747               		.comm usbConfiguration,1,1
 748               		.comm usbRxBuf,22,1
 749               		.comm usbInputBufOffset,1,1
 750               		.comm usbDeviceAddr,1,1
 751               		.comm usbNewDeviceAddr,1,1
 752               		.comm usbRxLen,1,1
 753               		.comm usbCurrentTok,1,1
 754               		.comm usbRxToken,1,1
 755               		.comm usbTxBuf,11,1
 774               		.text
 776               	.Letext0:
 777               	/* File "usbdrv/usbdrv.c": code  312 = 0x0138 ( 302), prologues   4, epilogues   6 */
DEFINED SYMBOLS
                            *ABS*:00000000 usbdrv.c
     /tmp/ccHeDMsX.s:2      *ABS*:0000003f __SREG__
     /tmp/ccHeDMsX.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccHeDMsX.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccHeDMsX.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccHeDMsX.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccHeDMsX.s:96     .text:00000000 usbInit
     /tmp/ccHeDMsX.s:124    .text:0000000e usbPoll
                            *COM*:00000001 usbRxLen
                            *COM*:00000001 usbInputBufOffset
                            *COM*:00000016 usbRxBuf
                            *COM*:00000001 usbRxToken
     /tmp/ccHeDMsX.s:661    .data:00000001 usbTxLen
                            *COM*:0000000b usbTxBuf
                            *COM*:00000002 usbMsgPtr
                            *COM*:00000001 usbNewDeviceAddr
     /tmp/ccHeDMsX.s:704    .progmem.data:0000002e usbDescriptorDevice
     /tmp/ccHeDMsX.s:726    .progmem.data:00000040 usbDescriptorConfiguration
     /tmp/ccHeDMsX.s:667    .progmem.data:00000000 usbDescriptorString0
     /tmp/ccHeDMsX.s:675    .progmem.data:00000004 usbDescriptorStringVendor
     /tmp/ccHeDMsX.s:694    .progmem.data:00000022 usbDescriptorStringDevice
                            *COM*:00000001 usbConfiguration
                             .bss:00000000 usbMsgFlags
     /tmp/ccHeDMsX.s:656    .data:00000000 usbMsgLen
                            *COM*:00000001 usbDeviceAddr
                            *COM*:00000001 usbCurrentTok

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
usbFunctionSetup
usbFunctionWrite
usbFunctionRead
usbCrc16Append
